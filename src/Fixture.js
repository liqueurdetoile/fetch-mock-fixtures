import ResponseConfigurator from './helpers/ResponseConfigurator';
import RequestMatcher from './helpers/RequestMatcher';
import pathToRegexp from 'path-to-regexp';

export class Fixture extends ResponseConfigurator {
  /**
   * Stores the number of responses generated by this fixture
   * @type {Number}
   */
  calls = 0;

  ownCalls = [];
  globalCalls = [];

  /**
   * Flag for response configuration
   * @type {null|Number}
   */
  _callnum = null;
  _matcher = null;
  _ownCall = false;

  constructor(server) {
    super(server);
  }

  get on() {
    if (this._mode === 'respond') return this.server.on;

    this._matcher = this._matcher || new RequestMatcher(this);

    return new Proxy(this._matcher, {
      get: (obj, prop) => prop in obj ? obj[prop] : obj.getProcessor(prop.toLowerCase())
    });
  }

  _getCurrentResponseSet() {
    if (this._callnum !== null) {
      if (this._ownCall) {
        this.ownCalls[this._callnum] = this.ownCalls[this._callnum] || {}
        return this.ownCalls[this._callnum];
      }
      this.globalCalls[this._callnum] = this.globalCalls[this._callnum] || {}
      return this.globalCalls[this._callnum] || {};
    }

    this._any = this._any || {};
    return this._any;
  }

  preset(name) {
    const preset = this.server._presets[name];

    if (!preset) throw new Error('Unknown preset');

    this.set(preset._any);

    return this;
  }

  get to() {
    return this;
  }

  firstCall(own = false) {
    this._callnum = 1;
    this._ownCall = own;

    return this;
  }

  secondCall(own = false) {
    this._callnum = 2;
    this._ownCall = own;

    return this;
  }

  thirdCall(own = false) {
    this._callnum = 3;
    this._ownCall = own;

    return this;
  }

  call(n, own) {
    this._callnum = parseInt(n, 10) - 1;
    this._ownCall = own;

    return this;
  }

  get any() {
    this._callnum = null;
    this._ownCall = false;

    return this;
  }

  async match(request) {
    let matched = true;

    if (!this._matcher) return matched;

    return await this._matcher.match(request);
  }

  async sleep(delay) {
    await new Promise(resolve => setTimeout(resolve, delay));
  }

  extractParams(pathname, pattern) {
    const params = {};
    const keys = [];
    const re = pathToRegexp(pattern, keys);
    const parsed = re.exec(pathname);

    for (let i = 0; i < keys.length; i++) {
      let name = keys[i].name;
      let value = parsed[i+1];

      params[name] = value;
    }

    return params;
  }

  wrap(body, wrapper) {
    if (wrapper instanceof Function) return wrapper(body);

    return body || null;
  }

  getPath(request, response) {
    let url = response.pattern || request.pathname;
    let path = url.split('/').filter(p => p && p.indexOf(':') < 0);
    let filename = request.method.toLowerCase();

    return path.concat(filename).join('/');
  }

  async _buildResponse(request, response) {
    // Process before hook and update response if one is returned
    if (response.before instanceof Function) {
      try {
        let responseReplacement = await response.before.call(this, this.server, request, response);
        if (responseReplacement) response = responseReplacement;
      } catch (err) {
        return new Response(err.toString(), {
          status: 500,
          statusText: 'Unable to process before hook'
        });
      }
    }

    // Destructure response
    let {body, headers, status, statusText, ...extras} = response;

    // Extract params if a pattern have been set
    extras.params = extras.pattern ? this.extractParams(request.pathname, extras.pattern) : {};    

    // Process body callback
    try {
      if (body instanceof Function) body = await body(extras.params, request, this.server);
    } catch (err) {
      return new Response(err.toString(), {
        status: 500,
        statusText: 'Unable to process body callback'
      });
    }

    // Construct response
    const responseObject = new Response(this.wrap(body, extras.wrapper), {headers, status, statusText});

    // Process after hook
    try {
      if (extras.after instanceof Function) await extras.after.call(this, this.server, responseObject);
    } catch (err) {
      return new Response(err.toString(), {
        status: 500,
        statusText: 'Unable to process after hook'
      });
    }

    // Delay response
    if (extras.delay) await this.sleep(extras.delay);

    return responseObject;
  }

  getResponse(request) {
    const localCalls = ++this.calls;
    const globalCalls = this.server.calls;

    // Match local calls first
    return this._buildResponse(request,
      this.ownCalls[localCalls] ||
      this.globalCalls[globalCalls] ||
      this._any
    );
  }
}

export default Fixture;
